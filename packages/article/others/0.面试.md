1. set(稽核)和map(字典)

1. BFC

    块级格式化上下文.它是一个独立的渲染区域。触发BFC：html、float、overFlow为hidden或scroll、display的值为inline-block、table-cell、table-caption、position的值为absolute或fixed
1. 移动端适配（1px）
    rem布局、vh、vw布局、viewport

1. http和tcp协议

1. 路由守卫
    全局前置：beforeEach
    全局解析: beforeResolve
    全局后置: afterEach
    路由独享: beforeEnter
    组件守卫: beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
    流程:
        导航被触发。
        在失活的组件里调用离开守卫。
        调用全局的 beforeEach 守卫。
        在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
        在路由配置里调用 beforeEnter。
        解析异步路由组件。
        在被激活的组件里调用 beforeRouteEnter。
        调用全局的 beforeResolve 守卫 (2.5+)。
        导航被确认。
        调用全局的 afterEach 钩子。
        触发 DOM 更新。
        用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。


1. http缓存 -- 强缓存和协商缓存
    强缓存： Expires（超期时间） 和
            Cache-Control：
                （1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；
                （2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；
                （3）public：指示响应可被任何缓存区缓存；
                （4）private：只能针对个人用户，而不能被代理服务器缓存；
                （5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
                （6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。
    协商缓存


1. 跨域

1. nextTick

1. vue的生命周期
    1. beforeCreate（创建前） 在数据观测和初始化事件还未开始
    1. created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
    1. beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上
    1. 载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
    1. beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
    1. beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。
    1. destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
    1. activated
    1. deactivated

1. vue3
    Proxy可以检测到属性的新增和删除，可以检测到数组索引的和length的变化， 支持map、set、weakMap、weakSet
    使用ts重构、增强ts的支持

1. http2



1. https
    1.客户端向服务器发起HTTPS请求，连接到服务器的443端口
    2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
    3.服务器将自己的公钥发送给客户端。
    4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
    5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
    6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
    7.然后服务器将加密后的密文发送给客户端。
    8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

1. webpack

    DefinePlugin ：允许创建一个在编译时可以配置的全局变量
    使用DllPlugin可以减少基础模块编译次数，动态链接库插件，其原理是吧网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。在dll中大多包含的时常用的第三方模块，只要这些模块版本不升级，就只需要被编译一次。

1.  如何利用webpack来优化前端性能

    5.1. 压缩代码。uglifyJsPlugin 压缩js代码， mini-css-extract-plugin 压缩css代码
    5.2. 利用CDN加速，将引用的静态资源修改为CDN上对应的路径，可以利用webpack对于output参数和loader的publicpath参数来修改资源路径
    5.3. 删除死代码（tree shaking），css需要使用Purify-CSS
    5.4. 提取公共代码。webpack4移除了CommonsChunkPlugin (提取公共代码)，用optimization.splitChunks和optimization.runtimeChunk来代替

1. vue首屏优化
    1. 打包优化， 减少代码体积，代码加载速度
    1. 路由懒加载
    1. 启动gzip压缩
    1. 代码优化，合理使用v-if v-show watch和computed
    1. 组件动态引入、按需引入


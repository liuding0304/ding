# 高阶函数

## 柯里化（currrying）

 柯里化又称`部分求值`, 一个柯里化函数会先接受一些参数, 接受之后保存起来,不立即求值,而是通过闭包保存起来,并返回一个函数. 当函数要真正求值的时候, 会将之前的所有参数一次性求值.


``` js
var currying = function(fn) {
  var args = [];

  return function() {
    if( arguments.length === 0 ){
      return fn.apply(this, args);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee;
    }
  }
};

```

## 函数节流

　某个函数有可能被频繁的触发，从而影响性能，这样的函数就需要节流

- 定时器节流

```js
var throttle = function(fn,interval) {

  var _self = fn,   // 保存需要被延迟执行的函数引用
      timer,    // 定时器
      firstTime = true,   // 是否是第一次调用该函数
      intervalDefault = 500;

  return function() {
    var args = arguments,
        _me = this;

    if(firstTime) {
      _self.apply(_me, args);
      return firstTime = false;
    }

    if(timer) {
      return false;
    }

    timer = setTimeout(function() {
      clearTimeour(timer);
      timer = null;
      _self.apply(_me, args);
    }, interval || intervalDefault);

  }

}
```

## 分时函数

``` js
var timeChunk = function(ary, fn, count) {





}
```

## 惰性加载函数

因为一些浏览器的差异, 需要一写嗅探工作,比如每添加一个点击事件就嗅探一次. 不过这里有更好的办法. 把嗅探浏览器的操作提前到代码加载的时候.

``` js
var addEvent = function(ele, type, handler) {
  if(window.addEventLister) {
    addEvent = function(ele, type, handler) {
      ele.addEventLister(type, handler, false);
    }
  } else if(window.attachEvent) {
    addEvent= function(ele, type, handler){
      ele.attachEvent('on'+ type, handler);
    }
  }
  addEvent(ele, type, handler);
}
```